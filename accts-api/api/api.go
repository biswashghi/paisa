package api

import (
	"context"
	"encoding/json"
	"io"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/shopspring/decimal"
	"golang.org/x/crypto/bcrypt"
)

/*
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
*/

// Create a rewards accounts. The rewards account id is autogenerated and returned to the caller.
func (newApiRequest *ApiAccess) CreateRewardsAccount(w http.ResponseWriter, r *http.Request) {

	var body CreateAccountRequest
	if body.AccountId == "" {
		log.Printf("No accountId provided, assigning a randomly generated id.")
		body.AccountId = uuid.NewString()
	}

	newAccount := AccountSnapshot{
		AccountId:      body.AccountId,
		RewardsBalance: decimal.Decimal{},
	}

	log.Printf("Creating Account: %s", newAccount.AccountId)
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	// insert the new account into the postgres database
	var err error
	_, err = newApiRequest.AccountsDB.ExecContext(ctx, "INSERT INTO paisa.accounts (accountId) VALUES ($1)", newAccount.AccountId)
	if err != nil {
		log.Printf("Error inserting into postgres: %s", err)
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}

	respondWithJSON(w, http.StatusOK, newAccount)
}

/*
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
*/

// Return the full information about the provided accounts
func (newApiRequest *ApiAccess) GetRewardsAccount(w http.ResponseWriter, r *http.Request) {

	params := mux.Vars(r)
	accountId := params["accountId"]
	log.Printf("Get Account Details: %s", accountId)

	var account AccountSnapshot
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()
	err := newApiRequest.AccountsDB.QueryRowContext(ctx, "SELECT accountId, balance FROM paisa.accounts WHERE accountId = $1", accountId).Scan(&account.AccountId, &account.RewardsBalance)
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}
	respondWithJSON(w, http.StatusOK, account)
}

// Return the full information about the provided accounts
func (newApiRequest *ApiAccess) GetAccountTransactions(w http.ResponseWriter, r *http.Request) {

	params := mux.Vars(r)
	accountId := params["accountId"]
	log.Printf("Get all transaction information: %s", accountId)

	start_page := r.URL.Query().Get("start_page")
	// log.Printf("%s", start_page)
	if start_page == "" {
		start_page = "0"
	}
	start_page_int, _ := strconv.Atoi(start_page)

	page_size := r.URL.Query().Get("page_size")
	// log.Printf("%s", page_size)
	if page_size == "" {
		page_size = "10"
	}
	page_size_int, _ := strconv.Atoi(page_size)

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	var transactions []TransactionHistory
	cursor, err := newApiRequest.AccountsDB.QueryContext(ctx, "SELECT transactionId, accountId, description, merchantCode, increment, timestamp FROM paisa.transactions WHERE accountId = $1 ORDER BY timestamp DESC LIMIT $2 OFFSET $3", accountId, page_size_int, start_page_int*page_size_int)
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}
	// read the results into a slice of TransactionHistory
	for cursor.Next() {
		var transaction TransactionHistory
		err := cursor.Scan(&transaction.TransactionId, &transaction.AccountId, &transaction.Description, &transaction.MerchantCode, &transaction.Increment, &transaction.CreatedAt)
		if err != nil {
			respondWithError(w, http.StatusInternalServerError, err.Error())
			return
		}
		transactions = append(transactions, transaction)
	}

	if err != nil {
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}

	log.Printf("Returning %d transaction", len(transactions))
	respondWithJSON(w, http.StatusOK, transactions)
}

/*
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
*/

func (newApiRequest *ApiAccess) UpdateRewardsBalance(w http.ResponseWriter, r *http.Request) {

	decoder := json.NewDecoder(r.Body)
	var body UpdateBalanceRequest
	err := decoder.Decode(&body)
	if err != nil {
		log.Printf("Error decoding request body: %s", err)
		respondWithError(w, http.StatusBadRequest, "Improper Increment")
	}

	params := mux.Vars(r)
	accountId := params["accountId"]
	log.Printf("Updating Account Balance: %s$ for %s", body.Increment, accountId)

	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	var account AccountSnapshot
	transaction := TransactionHistory{
		AccountId:    accountId,
		Description:  body.Description,
		MerchantCode: body.MerchantCode,
		Increment:    body.Increment,
	}

	//create a postgesql transaction
	tx, err := newApiRequest.AccountsDB.BeginTx(ctx, nil)
	if err != nil {
		log.Printf("Error starting transaction: %s", err)
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}
	// insert the transaction in the transactions table
	_, err = tx.ExecContext(ctx, "INSERT INTO paisa.transactions (accountId, description, merchantCode, increment) VALUES ($1, $2, $3, $4)", transaction.AccountId, transaction.Description, transaction.MerchantCode, transaction.Increment)
	if err != nil {
		log.Printf("Error inserting into postgres: %s", err)
		tx.Rollback()
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}

	// update the account balance in the accounts table and return the updated account
	err = tx.QueryRowContext(ctx, "UPDATE paisa.accounts SET balance = balance + $1 WHERE accountId = $2 RETURNING balance", transaction.Increment, transaction.AccountId).Scan(&account.RewardsBalance)
	if err != nil {
		log.Printf("Error updating account balance: %s", err)
		tx.Rollback()
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}
	// commit the transaction
	err = tx.Commit()
	if err != nil {
		log.Printf("Error committing transaction: %s", err)
		respondWithError(w, http.StatusInternalServerError, err.Error())
		return
	}

	log.Printf("Transaction Record Added for %s", accountId)
	log.Printf("Account Balance Updated: %s$ for %s", body.Increment, accountId)
	respondWithJSON(w, http.StatusOK, account)
}

/*
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
*/

func (newApiRequest *ApiAccess) HealthCheckHandler(w http.ResponseWriter, r *http.Request) {

	// A very simple health check.
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)

	// In the future we could report back on the status of our DB, or our cache
	// (e.g. Redis) by performing a simple PING, and include them in the response.
	io.WriteString(w, `{"alive": true}`)
}

/*
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
*/

// Register a new user and create a rewards account
func (newApiRequest *ApiAccess) RegisterUser(w http.ResponseWriter, r *http.Request) {
	var body RegisterRequest
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid request body")
		return
	}
	err = json.Unmarshal(bodyBytes, &body)
	if err != nil {
		respondWithError(w, http.StatusBadRequest, "Invalid request body")
		return
	}
	if body.Username == "" || body.Password == "" {
		respondWithError(w, http.StatusBadRequest, "Username and password are required")
		return
	}
	// Check if user already exists
	var existingId string
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()
	err = newApiRequest.AccountsDB.QueryRowContext(ctx, "SELECT accountid FROM paisa.users WHERE username=$1", body.Username).Scan(&existingId)
	if err == nil && existingId != "" {
		respondWithError(w, http.StatusConflict, "Username already exists")
		return
	}
	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(body.Password), bcrypt.DefaultCost)
	if err != nil {
		respondWithError(w, http.StatusInternalServerError, "Could not hash password")
		return
	}
	// Create new user and account
	newAccountId := uuid.NewString()
	tx, err := newApiRequest.AccountsDB.BeginTx(ctx, nil)
	if err != nil {
		log.Printf("Error starting transaction: %s", err)
		respondWithError(w, http.StatusInternalServerError, "Could not start transaction")
		return
	}
	_, err = tx.ExecContext(ctx, "INSERT INTO paisa.users (accountid, username, password) VALUES ($1, $2, $3)", newAccountId, body.Username, string(hashedPassword))
	if err != nil {
		log.Printf("Error creating user: %s", err)
		tx.Rollback()
		respondWithError(w, http.StatusInternalServerError, "Could not create user")
		return
	}
	_, err = tx.ExecContext(ctx, "INSERT INTO paisa.accounts (accountid) VALUES ($1)", newAccountId)
	if err != nil {
		log.Printf("Error creating account: %s", err)
		tx.Rollback()
		respondWithError(w, http.StatusInternalServerError, "Could not create account")
		return
	}
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %s", err)
		respondWithError(w, http.StatusInternalServerError, "Could not commit transaction")
		return
	}
	respondWithJSON(w, http.StatusOK, RegisterResponse{AccountId: newAccountId, Message: "User registered and account created successfully"})
}
